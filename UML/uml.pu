@startuml uml

hide empty fields

'TODO: '
'1. Enumerazione simboli e colori '
'2. frecce di composizione per struttura - carte '
'3. metodi Game '
'4. tutto controller '
'5. come inserire, cosa inserire per la view '
'6. inserire network? '

package model {

    class Game {
        - gameId: int
        - observerList: List<View>
        - numPlayers: int
        - numParticipants: int
        '- ?StadioGioco
        - currentPlayer: COLORE
        '?Board con dizionario colore punteggio
        'check sull'istanza array
        - commonObjectives: int[2]
        - placedCards: int[2][2]

        'General'

        'Initial'
        + drawResourceCards() : void
        + drawGoldCard() : void
        + drawSecretObjective() : void
        'Board'
        + getPoints( COLORE colore) : int
        + futurePoints () : int
        'Structure'
        + insertCard() : void
        + checkPattern(): void
        + calculateCurrentResources(): void
        + calculatePoints(): void
        + notifyAll(): void
        + addObserver(view: View): void
        + removeObserver(view: View): void
    }

    class Player {
        - nickname: String
        - colorPlayer: COLOR

        + getNickname(): String
        + getColorPlayer(): COLOR
    }

    class Board {
        + getPoints( COLORE colore) : int
        + futurePoints () : int
    }

    class Card {
        'colore lo codifichiam nell'id? o lo salviamo in una var?
        - idCard: int
        - codeFront: char[]
        - codeBack: char[]
        - cardPoints: int[]

        + getIdCard(): int
        + getCodeFront(): char[]
        + getCodeBack(): char[]
        + getCardPoints(): int[]
    }

    class ObjectiveCard extends Card {
        'tipo dell'obiettivo con enum? o codificato?'
        'non chiarissimo come caratterizzare l'obiettivo'
    }

    class AngledCard extends Card {
        - cardCorners: int[2][2]
        'decidere valore di default per corner non presente, corner presente non collegato, Id/puntatore carrta'
        - cardSymbols: SIMBOLO[2][2]

        + getCardCorners(): int[2][2]
        + getCardSymbols(): SIMBOLO[2][2]
    }

    class GoldCard extends AngledCard {
        - resources: SIMBOLO[5]
        'tipo ^ da capire'
        'caratterizzare tipo obiettivo'

        + getResources(): SIMBOLO[5]
    }

    class InitialCard extends AngledCard {
        - centerResources: SIMBOLO[3]
        'tipo da capire'

        + getCenterResources(): SIMBOLO[3]
    }

    class ResourceCard extends AngledCard {}

    class Structure {
        + insertCard() : void
        + checkPattern(): void
        + calculateCurrentResources(): void
        + calculatePoints(): void
    }

    class Deck {
        'check sul tipo dinamico statico'
        - goldDeck: List<Card>
        - resourceDeck: List<Card>
    }

    class Hand {
        - secretObjective: int
        - cardsHand: int[3]

        + getSecretObjective(): int
        + getCardsHand(): int[3]
    }

    enum COLORE {
        YELLOW
        BLUE
        GREEN
        RED
    }

    enum SIMBOLI {
        VEGETABLE
        ANIMAL
        INSECT
        SHROOM
        FEATHER
        INK
        SCROLL
    }

    abstract class Event {
        - id: int
        - timeStamp: long
        + getEventId(): int
        + getTimeStamp(): long
    }

    class NewPlayerEvent extends Event{
        + createPlayerEvent(playerView: View): void
    }

    class NewGameEvent extends Event{
        + createGameEvent(gameView: View): void
    }

    package updategameevent {
        class GameBoardUpdateEvent {
            + createGameBoardEvent(boardView: View): void
        }

        class GameDeckUpdateEvent {
            + createGameDeckEvent(deckview: View): void
        }

        class GameHandUpdateEvent {
            + createGameHandEvent(handView: View): void
        }

        class GameStructureUpdateEvent {
            + createGameStructureEvent(structureView: View): void
        }
    }

    class ChatMessage {
        - messageId: int
        - message: String
        - sender: Player
        - receiver: List<Player>
        - timeStamp: long
    }

    class Chat {
        - chatMessages: List<ChatMessage>
        + addMessage(message: ChatMessage): void
        + removeMessage(message: ChatMessage): void
    }
}

package controller {
    class ServerController{
        -view: View
        -modelBoard: Board 
        -eventQueue: Queue<Event>
        -modelStructure: Structure
        -modelHand: Handwritten
        -modelDeck: Deck 
        -modelChat: Chat 
        -modelGame: Game
        -modelPlayer: Player


        ' Controller state changes

        + lastTurn(): void
        + initialTurn(): void
        + computePoints(playerList:List<Player>) : List<int>
        + computePointsBy(player: Player): int
        + turnEnded(): void

        + cardPlaced(card:angledCard, player:Player):void
        + computeStructurePointsBy(player:Player)

        +drawCard():void
        +placeCard():void

        +sendMessage(message:String): void


        'User gesture consumer from view 

        +update():void
        +selectView():void
    }

    note bottom
    It reacts to events thrown by the view by updating 
    the task queue and holds the logics to compute the 
    result of user actions and perform changes on the
    state. It acts selectiong the view that requires changes.
    end note


    class FlowController{
        -view: View
        -modelBoard: Board 
        -modelGame: Game
        -eventQueue: Queue<Event>


        'Controller state changes

        +createGame():void
        +deleteGame():void
        +admitPlayer():void
        +setNickname(nick:String):void throws AlreadyExistingNicknameException
        +setNumPlayers(num:int):void
        +setConnectionType():void


        'User gesture consumer from view 

        +update():void
    }

    note bottom
    It holds the multiplayer logic and the management
    of inital settings
    end note

    class ClientController{
        -view: View
        -eventQueue: Queue<Event>


        'Action performed by user that doesn't affect the state of the model

        +whosTurn():Player throws NotYourTurnException 
        +suitablePlaced():boolean throws IllegalPlacementAnglesException , IllegalPlacementResourcesException 
        +suitableOrder():boolean throws IllegalSequeceException 
        +hint():Card


        'User gesture consumer from view 

        +update():void
    }

    note bottom
    It handles part of game's logic. Specifically it reacts to user's attempt to make 
    illegal moves blocking him from changing the state of the model and, given the current state
    of the game it gives hints on the best card choice.
    It doesn't interact with the model.

    end note
}

package view {
    abstract View {
        - gameModel: Game
        - boardModel: Board
        - playerModel: Player
        - deckModel: Deck
        - handModel: Hand
        - structureModel: Structure
        - eventQueue: Queue<Event>
        - controllerList: List<Controller>
        + addEvent(event: Event): void
        + removeEvent(event: Event): void
        + update(): void
        + addListener(controller: Controller): void
        + removeListener(controller: Controller): void
        + notifyAll(): void
    }

    package boardview {
        class BoardViewGui {}
        class BoardViewCli {}
    }

    package playerview {
        class PlayerViewGui {}
        class PlayerViewCli {}
    }

    package deckview {
        class DeckViewGui {}
        class DeckViewCli {}
    }

    package handview {
        class HandViewGui {}
        class HandViewCli {}
    }

    package structureview {
        class StructureViewGui {}
        class StructureViewCli {}
    }

    package gameview {
        class GameViewGui {}
        class GameViewCli {}
    }
}

Game -- Player
Game -- Deck
Game -- Board
Deck -- Card
Player -- Hand
Player -- Structure
Structure -- Card
Hand -- Card

Chat -- ChatMessage

updategameevent --|> Event

BoardViewGui --|> View
BoardViewCli --|> View
PlayerViewGui --|> View
PlayerViewCli --|> View
DeckViewGui --|> View
DeckViewCli --|> View
HandViewGui -up-|> View
HandViewCli -up-|> View
StructureViewGui -up-|> View
StructureViewCli -up-|> View
GameViewGui -up-|> View
GameViewCli -up-|> View

@enduml
