@startuml uml
hide empty fields
' skinparam linetype ortho

package model {
    class Game {
        - gameId: int
        - gameState: State
        - players: Player[4]
        - playerHand: Hand[4]
        - playerStructure: Structure[4]
        - deck: Deck
        - board: Board
        - numPlayers: int
        - numParticipants: int
        '- ?StadioGioco
        - currentPlayer: Player
        - nextPlayer: Player
        - observerList: List<View>
        'General'
        
        + game(): void
        + notifyAll(): void
        + addObserver(view: View): void
        + removeObserver(view: View): void
        + setState(state: State): void
        + getCurrentPlater(): Player
        + getState(): State
        + getDeck(): Deck
        + getBoard(): Board
    }

    class Player {
        - nickname: String
        - colorPlayer: Color
        - structure: Structure
        - hand: Hand
        
        + player(): Player
        + getNickname(): String
        + getColorPlayer(): Color
        }

    abstract class State {
        - game: Game

        + State(): void
        + initialize(): void
        + joinGame(): void
        + placedCard(): void
        + drawnCard(): void
        + matchEnded(): void
    }

    class InitState {
        + InitState(): void
        + initialized(): void
        - createDecks(): void
        - dealHands(): void
        - dealSecretObjective(): void
        - dealCommonObjective(): void
        - createFirstPlayer(): void
    }

    note bottom
    createDecks parses the json file and forall card in it calls the Deck's method "addCard". When finished it shuffles the deck calling on it the method "shuffle".
    end note
    
    class WaitPlayerState {
        + WaitPlayerState(): void
        + joinGame(): void
        - createNewPlayers(): void
        - isFull(): void
    }

    class PlacedCardState {
        + PlacedCardState(): void
        + placedCard(): void
        - addCard(): void
        - computePoints(): void
    }

    class DrawnCardState {
        + DrawnCardState(): void
        + drawnCard(): void
        + matchEnded(): void
        - updateDeck(): void
        - nextTurn(): void
        - endMatch(): void
    }

    class Board {
        - scores: Map<Color, int>
        - commonObjectives: int[2]
        - uncoveredCards: int[2][2]

        + Board(): void
        + updateScore(player: Color, newPoints: int): void
        'modifica la mappa dello Scores'
        + getCurrentPoints(player: Color): int
        + getFuturePoints(player: Color): int
        + isLastTurn(): boolean
    }

    abstract class Card {
        'Color lo codifichiam nell'id? o lo salviamo in una var?
        - idCard: int
        - codeFront: char[]
        - codeBack: char[]
        - cardPoints: int[]

        + Card(): void
        + getIdCard(): int
        + getCodeFront(): char[]
        + getCodeBack(): char[]
        + getCardPoints(): int[]
    }

    class ObjectiveCard extends Card {
        'tipo dell'obiettivo con enum? o codificato?'
        'non chiarissimo come caratterizzare l'obiettivo'

        + card(): ObjectiveCard
    }

    class AngledCard extends Card {
        - cardCorners: int[2][2]
        'decidere valore di default per corner non presente, corner presente non collegato, Id/puntatore carrta'
        - cardSymbols: Symbol[2][2]

        + card(): AngledCard
        + getCardCorners(): int[2][2]
        + getCardSymbols(): Symbol[2][2]
    }

    class GoldCard extends AngledCard {
        - resources: Symbol[5]
        'tipo ^ da capire'
        'caratterizzare tipo obiettivo'

        + card(): GoldCard
        + getResources(): Symbol[5]
    }

    class InitialCard extends AngledCard {
        - centerResources: Symbol[3]
        'tipo da capire'

        + card(): InitialCard
        + getCenterResources(): Symbol[3]
    }

    class ResourceCard extends AngledCard {}

    class Structure {
        'è necessario che abbia player se è unico di un playre?'
        - player: Color
        + playedCards(): List<Cards>
        'può restituire la prima carta della struttura da cui ripercorrere ricorsivamente le connessioni'
        'può restituire una lista con le connessioni ordinate'
        + connections(): int
        + insertCard() : void
        + checkPattern(): void
        + calculateCurrentResources(): void
        + calculatePoints(): void
    }

    class Deck {
        'check sul tipo dinamico statico'
        - goldDeck: List<Card>
        - resourceDeck: List<Card>

        + deck(): Deck
        + getGoldDeck(): List<Card>
        + getResourceDeck(): List<Card>
        + addGoldCard(card: GoldCard): void
        + addResourceCard(card: ResourceCard): void
        + drawGoldCard(): GoldCard
        + drawResourceCard(): ResourceCard
        + shuffleGoldDeck(): void
        + shuffleResourceDeck(): void
    }

    class Hand {
        - secretObjective: int
        - cardsHand: int[3]

        + getSecretObjective(): int
        + getCardsHand(): int[3]
    }

    enum Color {
        YELLOW
        BLUE
        GREEN
        RED
    }

    enum Symbol {
        VEGETABLE
        ANIMAL
        INSECT
        SHROOM
        FEATHER
        INK
        SCROLL
    }

    abstract class Event {
        - id: int
        - timeStamp: long
        + getEventId(): int
        + getTimeStamp(): long
    }

    enum NewPlayerEventType{
        PLAYER_JOINED
        ERROR_WHILE_ENTERING
        PLAYER_READY_TO_PLAY
        DISCONNECTED_PLAYER
    }

    enum NewGameEventType{
        GAME_STARTED
        GAME_ENDED
        GAME_ALREADY_FULL
    }

    class NewPlayerEvent extends Event{
        - type: NewPlayerEventType
        + createPlayerEvent(playerView: View): void
    }

    class NewGameEvent extends Event{
        - type: NewGameEventType
        + createGameEvent(gameView: View): void
    }

    package updategameevent {
        enum BoardEventType{
            NEXT_TURN
            LAST_TURN
            NEXT_PLAYER
            NEW_POSITION
            NEW_POINTS
        }
        enum DeckEventType{
            INIT
            CARD_PICKED
            NO_MORE_CARDS
        }
        enum HandEventType{
            CARD_PICKED
            CARD_PLACED
        }
        enum StructureEventType{
            CARD_PLACED
            RESOURCE_COUNT
        }

        class GameBoardUpdateEvent {
            - type: BoardEventType
            + createGameBoardEvent(boardView: View): void
        }

        class GameDeckUpdateEvent {
            - type: DeckEventType
            + createGameDeckEvent(deckview: View): void
        }

        class GameHandUpdateEvent {
            - type: HandEventType
            + createGameHandEvent(handView: View): void
        }

        class GameStructureUpdateEvent {
            - type: StructureEventType
            + createGameStructureEvent(structureView: View): void
        }
    }

    class ChatMessage {
        - messageId: int
        - message: String
        - sender: Player
        - receiver: List<Player>
        - timeStamp: long
    }

    class Chat {
        - chatMessages: List<ChatMessage>
        + addMessage(message: ChatMessage): void
        + removeMessage(message: ChatMessage): void
    }

    package exceptions{
        exception AlreadyExistingNicknameException{}
        exception IllegalPlacementAnglesException{}
        exception IllegalPlacementResourcesException{}
        exception IllegalSequeceException{}
    }
}

package controller {
    class ServerController{
        - view: View
        - modelBoard: Board 
        - eventQueue: Queue<Event>
        - modelStructure: Structure
        - modelHand: Handwritten
        - modelDeck: Deck 
        - modelChat: Chat 
        - modelGame: Game
        - modelPlayer: Player
        ' Controller state changes
        + lastTurn(): void
        + initialTurn(): void
        + computePoints(playerList: List<Player>): List<int>
        + computePointsBy(player: Player): int
        + turnEnded(): void
        + cardPlaced(card: angledCard, player: Player): void
        + computeStructurePointsBy(player: Player)
        + drawCard(): void
        + placeCard(): void
        + sendMessage(message:String): void
        'User gesture consumer from view 
        + update(): void
        + selectView(): void
        + addEvent(event: Event): void
        + removeEvent(event: Event): void
    }

    note bottom
    It reacts to events thrown by the view by updating 
    the task queue and holds the logics to compute the 
    result of user actions and perform changes on the
    state. It acts selectiong the view that requires changes.
    end note

    class FlowController{
        - view: View
        - modelBoard: Board 
        - modelGame: Game
        - eventQueue: Queue<Event>
        'Controller state changes
        + createGame(): void
        + deleteGame(): void
        + admitPlayer(): void
        + setNickname(nickName: String): void throws AlreadyExistingNicknameException
        + setNumPlayers(num: int): void
        + setConnectionType(): void
        'User gesture consumer from view 
        + update(): void
        + addEvent(event: Event): void
        + removeEvent(event: Event): void
    }

    note bottom
    It holds the multiplayer logic and the management
    of inital settings
    end note

    class ClientController{
        - view: View
        - eventQueue: Queue<Event>
        'Action performed by user that doesn't affect the state of the model
        + whosTurn(): Player throws NotYourTurnException 
        + suitablePlaced(): boolean throws IllegalPlacementAnglesException , IllegalPlacementResourcesException 
        + suitableOrder(): boolean throws IllegalSequeceException 
        + hint(): Card
        'User gesture consumer from view 
        + update(): void
        + addEvent(event: Event): void
        + removeEvent(event: Event): void
    }

    note bottom
    It handles part of game's logic. Specifically it reacts to user's attempt to make 
    illegal moves blocking him from changing the state of the model and, given the current state
    of the game it gives hints on the best card choice.
    It doesn't interact with the model.
    end note
}

package view {
    abstract View {
        - gameModel: Game
        - boardModel: Board
        - playerModel: Player
        - deckModel: Deck
        - handModel: Hand
        - structureModel: Structure
        - eventQueue: Queue<Event>
        - controllerList: List<Controller>
        + addEvent(event: Event): void
        + removeEvent(event: Event): void
        + update(): void
        + addListener(controller: Controller): void
        + removeListener(controller: Controller): void
        + notifyAll(): void
    }

    package boardview {
        class BoardViewGui {}
        class BoardViewCli {}
    }

    package playerview {
        class PlayerViewGui {}
        class PlayerViewCli {}
    }

    package deckview {
        class DeckViewGui {}
        class DeckViewCli {}
    }

    package handview {
        class HandViewGui {}
        class HandViewCli {}
    }

    package structureview {
        class StructureViewGui {}
        class StructureViewCli {}
    }

    package gameview {
        class GameViewGui {}
        class GameViewCli {}
    }
}

Game -- Player
Game -- Deck
Game -- Board
Deck -- Card
Player -- Hand
Player -- Structure
Structure -- Card
Hand -- Card

Chat -- ChatMessage

GameStructureUpdateEvent -up-|> Event
GameHandUpdateEvent -up-|> Event
GameDeckUpdateEvent -up-|> Event
GameBoardUpdateEvent -up-|> Event

BoardViewGui --|> View
BoardViewCli --|> View
PlayerViewGui --|> View
PlayerViewCli --|> View
DeckViewGui --|> View
DeckViewCli --|> View
HandViewGui -up-|> View
HandViewCli -up-|> View
StructureViewGui -up-|> View
StructureViewCli -up-|> View
GameViewGui -up-|> View
GameViewCli -up-|> View

InitState -up-|> State
WaitPlayerState -up-|> State
PlacedCardState -up-|> State
DrawnCardState -up-|> State

Game *-up-> State

GameBoardUpdateEvent --> BoardEventType : type
GameDeckUpdateEvent --> DeckEventType : type
GameHandUpdateEvent --> HandEventType : type
GameStructureUpdateEvent --> StructureEventType : type

NewPlayerEvent --> NewPlayerEventType : type
NewGameEvent --> NewGameEventType : type

left to right direction

' [ ] Sistema metodi duplicati
' [ ] Metodi specifici per aggiornamento modello -> Card, Board, Structure, Player, Hand
' [x] Struttura classe 'Structure' da chiarire -> Albero
' [ ] Strategy pattern per computePoints model
' [x] Sintassi controller
' [x] Sistemare tipi eventi
' [ ] Finire commenti metodi
' [ ] Abstract factory pattern per createPlayer

@enduml